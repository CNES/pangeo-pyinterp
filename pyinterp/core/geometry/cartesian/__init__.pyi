import collections.abc
from typing import Iterator, TypeVar, overload

from ....type_hints import NDArray1DFloat64
from . import algorithms

_ConceptElement = TypeVar("_ConceptElement", Point, LineString, Polygon)

_Concept = TypeVar(
    "_Concept",
    Point,
    LineString,
    Polygon,
    Segment,
    Ring,
    Box,
    MultiPoint,
    MultiLineString,
    MultiPolygon,
)

__all__ = [
    "Box",
    "LineString",
    "MultiLineString",
    "MultiPoint",
    "MultiPolygon",
    "Point",
    "Polygon",
    "Ring",
    "Segment",
    "_Concept",
    "_ConceptElement",
    "algorithms",
]

class Box:
    min_corner: Point
    max_corner: Point
    def __init__(
        self, min_corner: tuple[float, float] | None = None, max_corner: tuple[float, float] | None = None
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class LineString:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, lon: NDArray1DFloat64, lat: NDArray1DFloat64
    ) -> None: ...
    def append(self, point: Point) -> None: ...
    def clear(self) -> None: ...
    def to_arrays(self) -> tuple[NDArray1DFloat64, NDArray1DFloat64]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...

class MultiLineString:
    lines: list[LineString]  # _BaseModelView[LineString]
    def __init__(
        self, lines: collections.abc.Sequence[LineString] | None = ...
    ) -> None: ...
    def append(self, ls: LineString) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg: int) -> LineString: ...
    def __iter__(self) -> Iterator[LineString]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, ls: LineString) -> None: ...

class MultiPoint:
    points: list[Point]  # _BaseModelView[Point]
    @overload
    def __init__(
        self, points: collections.abc.Sequence[Point] | None= ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        xs: NDArray1DFloat64,
        ys: NDArray1DFloat64,
    ) -> None: ...
    def append(self, pt: Point) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, pt: Point) -> None: ...

class MultiPolygon:
    polygons: list[Polygon]  # _BaseModelView[Polygon]
    def __init__(
        self, polygons: collections.abc.Sequence[Polygon] | None = ...
    ) -> None: ...
    def append(self, poly: Polygon) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, index: int) -> Polygon: ...
    def __iter__(self) -> Iterator[Polygon]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index: int, item: Polygon) -> None: ...

class Point:
    x: float
    y: float
    def __init__(self, x: float = ..., y: float = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Polygon:
    inners: list[Ring]  # _BaseModelView[Ring]
    outer: Ring
    def __init__(
        self, exterior: Ring | None = None, interiors: collections.abc.Sequence[Ring] | None = None
    ) -> None: ...
    def append(self, ring: Ring) -> None: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Ring:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, lon: NDArray1DFloat64, lat: NDArray1DFloat64
    ) -> None: ...
    def append(self, point: Point) -> None: ...
    def clear(self) -> None: ...
    def to_arrays(self) -> tuple[NDArray1DFloat64, NDArray1DFloat64]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...

class Segment:
    a: Point
    b: Point
    def __init__(
        self, a: tuple[float, float] | None = None, b: tuple[float, float] | None = None
    ) -> None: ...
    def to_arrays(self) -> tuple[NDArray1DFloat64, NDArray1DFloat64]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...
