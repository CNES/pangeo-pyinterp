from typing import overload

from ..type_hints import NDArray1DFloat64, NDArray1DStr, NDArray2DStr
from .geometry.geographic import Box, MultiPolygon, Point, Polygon, Spheroid

class GeoHash:
    @staticmethod
    def error_with_precision(precision: int) -> tuple[float, float]: ...
    @staticmethod
    def from_string(code: str, round: bool = False) -> GeoHash: ...
    @staticmethod
    def grid_properties(
        box: Box, precision: int
    ) -> tuple[GeoHash, int, int]: ...
    def __init__(self, lon: float, lat: float, precision: int) -> None: ...
    def area(self, spheroid: Spheroid | None = ...) -> float: ...
    def bounding_box(self) -> Box: ...
    def center(self) -> Point: ...
    def integer_value(self, round: bool = ...) -> int: ...
    def neighbors(self) -> list[GeoHash]: ...
    def __eq__(self, arg: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def code(self) -> str: ...
    @property
    def number_of_bits(self) -> int: ...
    @property
    def precision(self) -> int: ...

def area(
    hash: NDArray1DStr, wgs: Spheroid | None = None
) -> NDArray1DFloat64: ...
@overload
def bounding_boxes(
    box: Box | None = None, precision: int = 1
) -> NDArray1DStr: ...
@overload
def bounding_boxes(
    polygon: Polygon | MultiPolygon, precision: int = 1, num_threads: int = 0
) -> NDArray1DStr: ...
def decode(
    hash: NDArray1DStr, round: bool = False
) -> tuple[NDArray1DFloat64, NDArray1DFloat64]: ...
def encode(
    lon: NDArray1DFloat64, lat: NDArray1DFloat64, precision: int = 12
) -> NDArray1DStr: ...
def transform(hash: NDArray1DStr, precision: int = 1) -> NDArray1DStr: ...
def where(
    hash: NDArray2DStr,
) -> dict[bytes, tuple[tuple[int, int], tuple[int, int]]]: ...
