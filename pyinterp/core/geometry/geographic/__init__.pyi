import collections.abc
from typing import Iterator, Literal, TypeVar, overload

import numpy as np

from ....type_hints import NDArray1DFloat64, NDArray1DUInt32, NDArray2DFloat64
from ... import config
from . import algorithms



_ConceptElement = TypeVar("_ConceptElement", Point, LineString, Polygon)

_Concept = TypeVar(
    "_Concept",
    Point,
    LineString,
    Polygon,
    Segment,
    Ring,
    Box,
    Spheroid,
    Coordinates,
    MultiPoint,
    MultiLineString,
    MultiPolygon,
)

__all__ = [
    "Box",
    "Coordinates",
    "LineString",
    "MultiLineString",
    "MultiPoint",
    "MultiPolygon",
    "Point",
    "Polygon",
    "RTree",
    "Segment",
    "Spheroid",
    "_Concept",
    "_ConceptElement",
    "algorithms",
]

class Box:
    min_corner: Point
    max_corner: Point
    def __init__(
        self, min_corner: tuple[float, float] | None = ..., max_corner: tuple[float, float] | None = ...
    ) -> None: ...
    @overload
    def centroid(self) -> Point: ...
    @overload
    def centroid(self, centerpoint: Point) -> Point: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Coordinates:
    def __init__(self, spheroid: Spheroid | None = ...) -> None: ...
    def ecef_to_lla(
        self,
        x: NDArray1DFloat64,
        y: NDArray1DFloat64,
        z: NDArray1DFloat64,
        num_threads: int = 0,
    ) -> tuple[NDArray1DFloat64, NDArray1DFloat64, NDArray1DFloat64]: ...
    def lla_to_ecef(
        self,
        lon: NDArray1DFloat64,
        lat: NDArray1DFloat64,
        alt: NDArray1DFloat64,
        num_threads: int = 0,
    ) -> tuple[NDArray1DFloat64, NDArray1DFloat64, NDArray1DFloat64]: ...
    def transform(
        self,
        target: Coordinates,
        lon: NDArray1DFloat64,
        lat: NDArray1DFloat64,
        alt: NDArray1DFloat64,
        num_threads: int = 0,
    ) -> tuple[NDArray1DFloat64, NDArray1DFloat64, NDArray1DFloat64]: ...
    @property
    def spheroid(self) -> Spheroid: ...

class LineString:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, lon: NDArray1DFloat64, lat: NDArray1DFloat64
    ) -> None: ...
    def append(self, point: Point) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...

class MultiLineString:
    lines: list[LineString]  # _BaseModelView[LineString]
    def __init__(
        self, lines: collections.abc.Sequence[LineString] | None = ...
    ) -> None: ...
    def append(self, ls: LineString) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg: int) -> LineString: ...
    def __iter__(self) -> Iterator[LineString]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, ls: LineString) -> None: ...

class MultiPoint:
    points: list[Point]  # _BaseModelView[Point]
    @overload
    def __init__(
        self, points: collections.abc.Sequence[Point] | None = ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        lons: NDArray1DFloat64,
        lats: NDArray1DFloat64,
    ) -> None: ...
    def append(self, pt: Point) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, pt: Point) -> None: ...

class MultiPolygon:
    polygons: list[Polygon]  # _BaseModelView[Polygon]
    def __init__(
        self, polygons: collections.abc.Sequence[Polygon] | None = ...
    ) -> None: ...
    def append(self, poly: Polygon) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, index: int) -> Polygon: ...
    def __iter__(self) -> Iterator[Polygon]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index: int, item: Polygon) -> None: ...

class Point:
    lat: float
    lon: float
    def __init__(self, lon: float = ..., lat: float = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Polygon:
    inners: list[Ring]  # _BaseModelView[Ring]
    outer: Ring
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, exterior: Ring, interiors: collections.abc.Sequence[Ring] = ...
    ) -> None: ...
    def append(self, ring: Ring) -> None: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Ring:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, lon: NDArray1DFloat64, lat: NDArray1DFloat64
    ) -> None: ...
    def append(self, point: Point) -> None: ...
    def clear(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...

class RTree:
    def __init__(self) -> None: ...
    def bounds(
        self,
    ) -> (
        tuple[
            np.ndarray[tuple[Literal[3]], np.dtype[np.float64]],
            np.ndarray[tuple[Literal[3]], np.dtype[np.float64]],
        ]
        | None
    ): ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def insert(
        self, coordinates: NDArray2DFloat64, values: NDArray1DFloat64
    ) -> None: ...
    def inverse_distance_weighting(
        self,
        coordinates: NDArray2DFloat64,
        config: config.rtree.InverseDistanceWeighting | None = None,
    ) -> tuple[NDArray1DFloat64, NDArray1DUInt32]: ...
    def kriging(
        self,
        coordinates: NDArray2DFloat64,
        config: config.rtree.Kriging | None = None,
    ) -> tuple[NDArray1DFloat64, NDArray1DUInt32]: ...
    def packing(
        self, coordinates: NDArray2DFloat64, values: NDArray1DFloat64
    ) -> None: ...
    def query(
        self,
        coordinates: NDArray2DFloat64,
        config: config.rtree.Query | None = None,
    ) -> tuple[NDArray2DFloat64, NDArray2DFloat64]: ...
    def radial_basis_function(
        self,
        coordinates: NDArray2DFloat64,
        config: config.rtree.RadialBasisFunction | None = None,
    ) -> tuple[NDArray1DFloat64, NDArray1DUInt32]: ...
    def size(self) -> int: ...
    def window_function(
        self,
        coordinates: NDArray2DFloat64,
        config: config.rtree.InterpolationWindow | None = None,
    ) -> tuple[NDArray1DFloat64, NDArray1DUInt32]: ...

class Segment:
    a: Point
    b: Point
    def __init__(
        self, a: tuple[float, float] | None = None, b: tuple[float, float] | None = None
    ) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, idx: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, idx: int, point: Point) -> None: ...

class Spheroid:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, semi_major_axis: float, flattening: float) -> None: ...
    def authalic_radius(self) -> float: ...
    def axis_ratio(self) -> float: ...
    def equatorial_circumference(
        self, semi_major_axis: bool = ...
    ) -> float: ...
    def equatorial_radius_of_curvature(self) -> float: ...
    def first_eccentricity_squared(self) -> float: ...
    def geocentric_radius(self, lat: float) -> float: ...
    def linear_eccentricity(self) -> float: ...
    def mean_radius(self) -> float: ...
    def polar_radius_of_curvature(self) -> float: ...
    def second_eccentricity_squared(self) -> float: ...
    def semi_minor_axis(self) -> float: ...
    def volumetric_radius(self) -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def flattening(self) -> float: ...
    @property
    def semi_major_axis(self) -> float: ...
